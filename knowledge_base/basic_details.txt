You are AkBot , a friendly AI assistant created by Anik Chand.
-Your main role is to share details ONLY about Anik Chand â€” his projects, skills, experiences, and portfolio.
-If asked something outside this scope (like politics, sports, or general knowledge), reply politely:
â€œIâ€™m here to talk about Anik Chand and his work. Would you like to know about his projects, skills, or experiences?â€
you can go beyong that scope ... but not too much. You can do simple maths calculations.
-Keep responses short, warm, and conversational. Add emojis occasionally ğŸ™‚.
-For technical topics, explain in a simple and clear way.
-For personal topics, respond empathetically.




The details of me (Anik Chand) are below:


ğŸ“„ Knowledge Base: Anik Chand

### ğŸ‘¤ About Me

I am Anik Chand, passionate about AI/ML, deep learning, and building intelligent systems.
I love solving real-world problems using data-driven approaches, and I actively contribute to open-source and mentoring initiatives.

Anik chand address :
Birbhum, West Bengal, India

portfolio link : https://portfolio-fawn-beta-28.vercel.app
resume link : https://drive.google.com/file/d/1CdQwBAh4v6P90z_6Bm2dG1g8lLMJbpHh/view

Anik Chand's resume link : https://drive.google.com/file/d/1CdQwBAh4v6P90z_6Bm2dG1g8lLMJbpHh/view

gmail : anikchand461@gmail.com
linkedin : https://www.linkedin.com/in/anik-chand-3b14b12b6/
github : https://github.com/anikchand461
kaggle : https://www.kaggle.com/anikchand
codolio account link : https://codolio.com/profile/anikchand461
mobile : +91 9153772355



## projects made by Anik Chand

### ğŸ’¬ AkBot

project link live link : https://akbot-mxe4.onrender.com

An AI-powered personalized chatbot built using RAG + Gemini API, integrated with FastAPI backend, ChromaDB for vector storage, and a responsive JS frontend. Deployed seamlessly on Render.

ğŸš€ Features

ğŸ§  Retrieval-Augmented Generation (RAG) for contextual answers from personal/project data
âš¡ FastAPI Backend for handling chatbot requests
ğŸ“‚ ChromaDB as vector database for efficient embeddings & retrieval
ğŸ¤– Gemini API integration for LLM responses
ğŸŒ Frontend with HTML/CSS/JS for chat interface
â˜ï¸ Deployed on Render with environment-based API key management
ğŸ›  Tech Stack

Backend: FastAPI, LangChain
Vector DB: ChromaDB
LLM API: Gemini API
Frontend: HTML, CSS, JavaScript
Deployment: Render
âš™ï¸ Setup & Installation

Clone the repo

git clone https://github.com/anikchand461/AkBot.git
cd ai-chatbot
Create virtual environment & install dependencies

python -m venv venv
source venv/bin/activate   # On Windows: venv\Scripts\activate
pip install -r requirements.txt
Set up environment variables
Create a .env file in the project root:

GEMINI_API_KEY=your_api_key_here
Run the backend

uvicorn app.main:app --reload
Open the frontend
Open index.html in your browser, or serve via any static hosting.

ğŸ“¦ Deployment on Render

Push your repo to GitHub.
Create a Render Web Service â†’ select FastAPI backend.
Add GEMINI_API_KEY under Environment Variables in Render Dashboard.
Deploy ğŸš€


### ğŸ¦ tierlesstweet

Generate high-quality, engaging Twitter (X) posts and matching AI-generated images based on your content's tone â€” whether it's for casual users, blue-tick professionals, or golden-tick brands.

ğŸŒ Live Demo

ğŸš€ Features

âœï¸ AI-Generated Tweets Uses Gemini 2.5 Flash to craft single-post tweets tailored to different Twitter tiers:

No Tick: Short, punchy tweets under 280 characters.
Blue Tick: Polished posts under 2500 characters.
Golden Tick: In-depth, authoritative content without character limits.
ğŸ¨ AI-Generated Images Uses Nebius AI Studio (Flux Schnell) to generate a unique image that matches the tweet content.

ğŸ” Clean Output Tweets are stripped of markdown formatting to ensure clean, platform-ready output.

ğŸ“ Auto-Save Images are saved and served from the /static/generated_images directory.

ğŸ› ï¸ Tech Stack

Backend: Python, Flask
LLM: Google Generative AI (Gemini 2.5 Flash)
Image Generator: Nebius AI Studio (Flux Schnell)
Deployment: Render
ğŸ“¸ Preview

Example Screenshot

Demo of tweet and image generation interface.
ğŸ“‚ Project Structure

tierlesstweet/
â”‚
â”œâ”€â”€ static/
â”‚   â””â”€â”€ generated_images/
â”œâ”€â”€ templates/
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ .env
â”œâ”€â”€ app.py
â””â”€â”€ README.md
ğŸ”§ Setup Instructions

Clone the Repository

git clone https://github.com/yourusername/tierlesstweet.git
cd tierlesstweet
Create and Activate a Virtual Environment

python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
Install Dependencies

pip install -r requirements.txt
Set Up Environment Variables Create a .env file and add your API keys:

GENAI_API_KEY=your_google_genai_key
NEBIUS_API_KEY=your_nebius_api_key
Run the App

python app.py
Open in Browser Navigate to http://127.0.0.1:5000 in your browser.

ğŸ§  How It Works

User inputs keywords and selects a tweet type (No Tick, Blue Tick, Golden Tick).
A prompt is built and passed to the Gemini model.
The resulting tweet is cleaned and passed as a prompt to the Nebius image model.
The tweet and its matching AI-generated image are displayed together.
âœ¨ Future Improvements

User authentication and history tracking
Option to download tweet + image as a bundle
Twitter API integration for direct posting
Dark mode UI and mobile responsiveness
ğŸ“œ License

This project is licensed under the MIT License.

ğŸ‘¨â€ğŸ’¼ Author

Made with â¤ï¸ by Abhiraj Adhikary and Anik Chand






### ğŸ§  Sentiment Analysis

This project demonstrates a stacking ensemble for a classification task on a high-dimensional, sparse dataset. It leverages several classical machine learning algorithms and builds a deep stacking pipeline with performance tuning and cross-validation to achieve high accuracy.

live link : https://sentimentt-analysis.streamlit.app

ğŸ“Š Dataset

Shape: (50000, 73392)
Type: Sparse matrix (99.87% sparse)
Features: Preprocessed vectorized inputs (likely from text data such as TF-IDF or bag-of-words)
Labels: Multi-class or binary classification
ğŸ›¡ï¸ Stacking Architecture

Layer 0 (Base Models):
    âœ”ï¸ SGDClassifier
    âœ”ï¸ LogisticRegression
    âœ”ï¸ LinearSVC
    âœ”ï¸ MultinomialNB

â†“ Outputs

Layer 1 (Meta Model):
    âœ”ï¸ LogisticRegression
âœ… Final Accuracy Results

Model	Accuracy (%)
MultinomialNB	85.41
BernoulliNB	85.27
LogisticRegression	88.64
LinearSVC	88.54
SGDClassifier	88.65
RidgeClassifier	86.09
PassiveAggressive	81.02
1-Layer Stack	89.15 âœ…
Deep Stack (2 layers)	89.09
âœ… Best performance achieved using 1-layer stacking with Logistic Regression as the meta-model.
ğŸ§ª Techniques Used

train_test_split from sklearn.model_selection

Grid Search (GridSearchCV) for hyperparameter tuning:

C for LogisticRegression, LinearSVC
alpha for MultinomialNB, SGDClassifier
StackingClassifier for layered architecture

accuracy_score for evaluation

mode() for hard voting in final layer

ğŸ§  Requirements

Install necessary packages:

pip install numpy scikit-learn scipy
ğŸ§  Learning Highlights

Using classical ML models in a stacked architecture
Understanding how and when additional layers in stacking help (or donâ€™t)
Measuring accuracy improvements layer-by-layer using validation and voting
ğŸ“Š Model Progression & Insights

This section outlines the iterative improvements made during model experimentation:

ğŸ”¹ Baseline Models (Naive Bayes Family)

Model	Accuracy (%)
GaussianNB	82.00
BernoulliNB	83.00
MultinomialNB	83.50
ğŸ”¹ After Hyperparameter Tuning (Grid Search)

Model	Tuned Accuracy (%)
MultinomialNB (alpha)	85.40
ğŸ”¹ Ensemble of Classical ML Models

Tried:

LogisticRegression
SGDClassifier
RidgeClassifier
PassiveAggressiveClassifier
LinearSVC
Among them, 4 models performed best, achieving around 87% accuracy.

ğŸ”¹ Grid Search on Top 4 Models

After tuning C, alpha, penalty, loss, the best accuracy improved to 88.6%.

ğŸ”¹ Stacking

Performed model stacking with:

Base Models: MultinomialNB, SGD, LogisticRegression, LinearSVC
Meta Model: LogisticRegression (solver='lbfgs')
Cross-Validation: 5-fold
ğŸŒŸ Final Accuracy: 89.12% ğŸŒŸ Cross-Validation Score: 89.15%

ğŸ”¹ Multi-layer Stacking Attempt

Tried adding a second stacking layer with Ridge & SGD followed by hard voting.

Result: Accuracy dropped to 89.09%
Conclusion: Layer 1 was already optimal. Extra depth didnâ€™t help.




### ğŸ§  Personality Predictor

A Streamlit web app that predicts whether a person is an introvert or extrovert based on behavioral traits using a Random Forest Classifier.

ğŸ”— Live Demo

ğŸ‘‰ Click to Try the App

ğŸ“Œ Features

Takes in 4 simple inputs:

Social event attendance
Frequency of going outside
Social media post frequency
Friends circle size
Predicts personality type: Introvert ğŸª« or Extrovert ğŸ‰

Built with:

Python ğŸ
Scikit-learn
Streamlit
Joblib
ğŸ§ª Dataset Info

Source: Kaggle Dataset

2900 rows Ã— 8 columns

Preprocessing steps:

Converted categorical variables to binary (Yes/No â†’ 1/0)
Selected features with positive correlation to target
Imputed missing values using SimpleImputer
Used Random Forest for classification
âš™ï¸ How to Run Locally

1. Clone the Repository

git clone https://github.com/your-username/personality-predictor.git
cd personality-predictor
2. Install Requirements

pip install -r requirements.txt
3. Run Streamlit App

streamlit run app.py
ğŸ“ File Structure

â”œâ”€â”€ app.py                # Main Streamlit app
â”œâ”€â”€ personality_model.pkl # Trained Random Forest model
â”œâ”€â”€ requirements.txt      # Python dependencies
â””â”€â”€ README.md             # Project documentation
ğŸ“Š Model Performance

âœ… Accuracy: 90.3%
ğŸ“ˆ RÂ² Score: 0.62
âœ”ï¸ Trained using RandomForestClassifier from Scikit-learn
ğŸ“„ License

This project is licensed under the MIT License.

ğŸ™‡â€â™‚ï¸ Author

Developed by Anik Chand

ğŸ”— LinkedIn | GitHub





### Quizly - AI-Powered Quiz Generation Application

Quizly is a state-of-the-art quiz generation application that utilizes the Google Gemini Generative AI API to create sophisticated, context-aware multiple-choice questions based on user-specified topics. Developed with a robust FastAPI backend and a clean, responsive HTML/CSS/JavaScript frontend, Quizly delivers a seamless user experience for learners and educators alike.

Features â€¢ AI-driven generation of dynamic, multiple-choice questions across a wide range of topics â€¢ Provides instant feedback and assessment for questions â€¢ Integrates with the Google Gemini API for advanced, context-rich question generation â€¢ User-friendly, clean, and minimalist interface

Tech Stack

Layer Technology Backend FastAPI Frontend HTML, CSS, JavaScript AI Model Google Gemini via API

Installation 1. Clone the Repository:

git clone https://github.com/your-username/Quizly.git cd Quizly

2.	Install Dependencies:
pip install -r requirements.txt

3.	Setup Environment Variables:
Create a .env file with your Gemini API key:

GENAI_API_KEY=your_google_gemini_api_key

4.	Run the Application Locally:
uvicorn main:app --reload

Deployment â€¢ Render: Set the start command as unicorn main:app --reload. â€¢ Railway: Configure the app and obtain the deployment URL from the Railway dashboard.

Usage 1. Open the app in a browser. 2. Enter desired topics (comma-separated). 3. Choose the number of questions. 4. Click â€œGenerate Quizâ€ to begin.

Contributing

We welcome contributions. To propose changes or enhancements, open an issue for discussion first. All PRs must adhere to project coding and documentation standards.

Authors 

Anik Chand and Abhiraj Adhikary





### ğŸš¨ Report Connect
AI-Powered Crime Hotspot Prediction & Reporting Platform

ğŸ“Œ Overview

This project is an AI-driven platform that allows users to anonymously report harassment cases while utilizing Machine Learning to predict potential crime hotspots. By combining crowdsourced data and AI-based analysis, it helps authorities and the public identify high-risk areas and take preventive measures.

ğŸ”¥ Key Features

âœ… 1. Anonymous & Secure Reporting

Users can report harassment cases without revealing their identity.
The reports include location, type of harassment, and description.
ğŸŒ 2. Real-Time Crime Mapping

A dynamic map displays reported harassment cases as red blurry markers.
More reports = Higher intensity, helping visualize crime-prone areas.
ğŸ¤– 3. AI-Powered Hotspot Prediction

Uses Kernel Density Estimation (KDE) to predict the next potential crime hotspot.
The predicted hotspot is marked in green, with intensity decreasing from the most severe to least severe.
ğŸ“ˆ 4. Data-Driven Insights

A curved graph dynamically updates to show crime trends across different locations.
The system highlights the area with the most reports in real-time.
ğŸ” 5. Crowdsourced Data Collection

Community-driven data collection improves predictive accuracy.
Allows law enforcement and citizens to stay informed about crime patterns.
âš¡ 6. Scalability & Future Expansion

Designed to handle large-scale data entries.
Initially, a CSV dataset with 10,000 reports will populate the database for AI model training.
After reaching this milestone, reports will be manually submitted by users.
ğŸ›  Tech Stack

Backend ğŸ–¥ï¸

Django (Python) for server-side processing.
SQLite3 for managing reports and predictions.
Frontend ğŸ¥

HTML, JavaScript, Bulma CSS for an intuitive user experience.
Leaflet.js & OpenStreetMap API for map visualization.
Machine Learning & AI ğŸ¤–

Kernel Density Estimation (KDE) for hotspot prediction.
Pandas & NumPy for data processing.
ğŸ”„ How It Works

1ï¸âƒ£ Report Submission

Users enter location, type of harassment, and description.
The system automatically fetches latitude & longitude based on the location name.
The report is stored securely in the database.
2ï¸âƒ£ Real-Time Visualization

A map dynamically updates to reflect new reports.
Crime hotspots are predicted using AI, ensuring proactive safety measures.
3ï¸âƒ£ Prediction Mechanism

The AI model analyzes historical crime data.
KDE determines the most likely future crime locations.
The top 20 hotspots are displayed with decreasing intensity (green border with blurred green inside).
4ï¸âƒ£ Prediction Mechanism

Community commenting feature to discuss about the crimes.
ğŸ“‚ Setting Up the Project

ğŸ”§ 1. Clone the Repository

    git clone https://github.com/yourusername/Report-Connect.git
    cd Report-Connect
ğŸ“¦ 2. Install Dependencies

    pip install -r requirements.txt
ğŸ”¥ 3. Run Migrations & Start Server

    python manage.py migrate
    python manage.py runserver
ğŸš€ Future Enhancements

Advanced AI Models: Improve prediction accuracy with Deep Learning.
User Alerts: Send notifications when users are in high-risk zones.
Integration with Law Enforcement: Provide verified data to help authorities take action.
Multilingual Support: Expand accessibility to a wider audience.
ğŸ† Impact & Goals

Empower communities to report incidents without fear.
Assist law enforcement in focusing efforts on high-risk areas.
Utilize AI & Big Data for proactive crime prevention.
ğŸ«‚ Together, we can make cities safer! ğŸ”¥

Authors -
Anik Chand, Abhiraj Adhikary, Anirban Chakraborty, Ayan Roy






### ğŸ’¼ SalaryAi

SalaryAi is an AI-powered salary prediction web application built using FastAPI, Machine Learning, HTML, CSS, and JavaScript. It enables users to input professional details such as age, gender, education level, job title, and years of experience â€” and instantly get a predicted salary based on trained data.

âš ï¸ Note: This application is based on salary data from the United States. Predictions are aligned with typical U.S. salary ranges.
ğŸš€ Features

ğŸ§  Machine learning-powered salary predictions
ğŸŒ Fast and lightweight API built with FastAPI
ğŸ¨ Responsive and user-friendly frontend interface
â¬‡ï¸ Dynamic dropdowns populated directly from training dataset values
ğŸ“¦ Model and preprocessing pipeline stored using joblib
ğŸ’  Tech Stack

Category	Tools Used
Backend	Python, FastAPI
Frontend	HTML, CSS, JavaScript
Machine Learning	Pandas, Scikit-learn, Joblib
API Testing	FastAPI Docs (Swagger UI)
Deployment	Uvicorn (Locally) / Render
ğŸ“Š Dataset Fields

Age (Float)
Gender (Dropdown: e.g., Male, Female, Other)
Education Level (Dropdown: e.g., Bachelor's, Master's, PhD)
Job Title (Dropdown: 190+ options from dataset)
Years of Experience (Float)
ğŸ–¼ï¸ Screenshot

SalaryAi Screenshot

ğŸ”§ How to Run Locally

1. Clone the Repository

git clone https://github.com/yourusername/SalaryAi.git
cd SalaryAi
2. Install Dependencies

pip install -r requirements.txt
3. Run the App

uvicorn main:app --reload
4. Access the Interface

Visit the frontend page at: http://localhost:8000
Or use the Swagger API at: http://localhost:8000/docs
ğŸ“‚ Project Structure

SalaryAi/
â”œâ”€â”€ main.py                # FastAPI backend
â”œâ”€â”€ predict_salary.pkl     # Trained ML pipeline      
â”œâ”€â”€ static/
â”‚   â”œâ”€â”€ index.html         # CSS styling, JavaScript logic
â”œâ”€â”€ requirements.txt       # Python dependencies
â””â”€â”€ README.md              # Project documentation
ğŸ“Œ Future Improvements

Add more countries and currencies
Authentication for user-specific history
Visualize trends with graphs (experience vs salary, etc.)
Host the model API on cloud
ğŸ§‘â€ğŸ’» Author

Anik Chand LinkedIn â€¢ GitHub





### BillVault ğŸ“œğŸ’°

BillVault is a Django-powered web application for managing and tracking bills securely and efficiently. It allows users to register, log in, and perform tasks like creating, viewing, and managing their bills.

ğŸ”— Live Site: https://billvault.pythonanywhere.com/accounts/login/

âœ¨ Features

ğŸ‘¤ User registration and authentication

ğŸ” Secure login/logout functionality

ğŸ§¾ Create, view, update, and delete bills

ğŸ—‚ Categorize and filter bills

ğŸ“± Responsive and user-friendly UI

ğŸ›  Admin dashboard for managing data

âš™ Tech Stack

Backend: Django (ğŸ Python)

Frontend: HTML, CSS, JavaScript (with Django Templates)

Database: SQLite ğŸ—ƒ (default, configurable)

Hosting: PythonAnywhere â˜

ğŸš€ Getting Started

âœ… Prerequisites

Make sure you have the following installed:

ğŸ Python 3.x

ğŸ“¦ pip

ğŸŒ± virtualenv (optional but recommended)

âš™ Installation

git clone https://github.com/your-username/billvault.git cd billvault python -m venv env source env/bin/activate # For Windows: env\Scripts\activate pip install -r requirements.txt python manage.py migrate python manage.py runserver

â¡ Visit: http://127.0.0.1:8000/accounts/login/ to access the login page.

ğŸ§‘â€ğŸ’» Usage

âœ Register a new account or log in

ğŸ“‹ Create and manage bills from your dashboard

ğŸ” Use filters to sort or find specific bills

ğŸ›¡ Admins can manage users and system-wide data from the admin panel

ğŸ“ Folder Structure

billvault/ â”œâ”€â”€ accounts/ # ğŸ” Custom user authentication â”œâ”€â”€ bills/ # ğŸ§¾ App for bill CRUD operations â”œâ”€â”€ static/ # ğŸ¨ CSS, JS, images â”œâ”€â”€ templates/ # ğŸ–¼ HTML templates â”œâ”€â”€ manage.py â”œâ”€â”€ db.sqlite3 â””â”€â”€ requirements.txt


Authors

Anik Chand , Abhiraj Adhikary, Ayan Roy, Anchal Sharma






### GitCollabIn

GitCollabIn is a web application designed to connect developers, foster collaboration, and streamline open-source project management. Integrated with GitHub, it allows users to share and contribute to projects while matching their skills with relevant opportunities.

Key Features

ğŸ” Skill-based project matching
ğŸ¤ Contributor request handling
ğŸ” GitHub OAuth login
ğŸ§­ Project listing and discovery
ğŸ§‘â€ğŸ’» Custom user profiles
Built with Django, Bulma CSS, and JavaScript, and deployed via Render, it offers a scalable, modern, and developer-friendly experience.

How to List Your Project ğŸš€

ğŸ” Log In using your GitHub account.
â• Click â€œCreate Projectâ€ on the homepage/dashboard.
ğŸ“ Fill out the form:
ğŸ”— GitHub repository URL (must match your username)
ğŸ“„ Requirements description
ğŸ‘¥ Number of contributors needed
ğŸ’¡ Desired skills
â˜• Optional: Buy Me a Coffee, Patreon, or PayPal support
âœ… Submit the project.
ğŸ“Œ Your project appears in the global list after validation.
How Collaborators Join Projects ğŸ‘¨â€ğŸ’»ğŸ‘©â€ğŸ’»

ğŸ” Browse the homepage for interesting projects.
ğŸ“˜ Click on a project to view details.
âœ‰ï¸ Submit a contributor request (visible if allowed).
ğŸ§¾ Project owner reviews and accepts/rejects your request.
âœ… Once accepted, you begin collaboration.
How Everyone Can View Projects ğŸŒ

ğŸ  Visit the home page (/) to see all public projects.
ğŸ“‹ Projects include descriptions, skills needed, and contributor slots.
âš¡ Cached GitHub data (README, forks) enhances performance.
ğŸ” Search & filter (planned) to help users find matching projects easily.
How to Get Your Matching Projects ğŸ§ 

ğŸ” Log in and update your skills in your profile.
âœ… A â€œMatched Projectsâ€ section appears on the home page.
âš™ï¸ Uses a skill-matching algorithm.
â±ï¸ Matching results are cached for 1 hour for better speed.
Automating Collaborator Requests ğŸ¤–

â³ Requests are auto-stored as â€œpendingâ€.
ğŸ”” Project owners receive a notification.
ğŸ§¾ Owner manually accepts or rejects requests.
ğŸ“ˆ Future: Auto-accept based on skill/reputation using Celery tasks/signals.
Add Your GitHub Classic Token ğŸ”‘

ğŸ” Log in and go to Edit Profile.
ğŸ“‹ Paste your GitHub Classic Token (40 characters).
ğŸ›¡ï¸ Token is masked for security.
ğŸš€ Used for enhanced API access (e.g., forks, issues).
How to Clone This Repository ğŸ’»

# Clone the repo
git clone https://github.com/anikchand461/GitCollabIn.git

# Navigate into the repo
cd GitCollabIn

# Create a virtual environment
python -m venv venv

# Activate it
# On Windows
venv\Scripts\activate
# On Mac/Linux
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Configure environment variables (if needed)

# Run migrations
python manage.py migrate

# Start the server
python manage.py runserver


---

Live Link ğŸ”—

https://gitcollabin.onrender.com


---

Tech Stack ğŸ› ï¸

Django: Backend framework for APIs and database interaction

Bulma CSS: Modern responsive CSS framework

JavaScript: Frontend interactivity

GitHub OAuth: Secure login and repository integration

Render: Hosting and deployment

---

Contribution â¤ï¸

Contributions are welcome!
ğŸ§ª Clone the repo,
ğŸ› ï¸ Explore the features,
âœ¨ Help build the future of open-source collaboration!

Authors

Anik Chand, Anchal Sharma, Abhiraj Adhikary







### ğŸŒ EcoFix - Your Environmental Guardian ğŸŒ¿

EcoFix Banner

Welcome to EcoFix â€“ a comprehensive platform dedicated to promoting environmental awareness and sustainability! ğŸš€ Whether you're passionate about reducing your carbon footprint or tracking environmental observations, EcoFix has you covered.

ğŸ“¦ Features

âœ¨ Submit Environmental Observations
ğŸ“¸ Report environmental issues by submitting observations with photos and descriptions.

âœ¨ Track Your Carbon Footprint
ğŸš—ğŸŒ± Calculate your carbon emissions based on your transportation, diet, and energy usage.

âœ¨ Real-Time Data Visualization
ğŸ“Š Analyze your environmental impact with easy-to-understand charts and reports.

âœ¨ User-Friendly Interface
ğŸ’» Intuitive design with responsive layouts for a seamless experience on all devices.

ğŸš€ Technologies Used

Python ğŸ
Django ğŸŒ
HTML5 & CSS3 ğŸ¨
JavaScript âœ¨
Bulma CSS Framework ğŸ› ï¸
SQLite ğŸ—„ï¸
ğŸ› ï¸ Installation & Setup Guide

Follow these steps to get EcoFix up and running on your local machine! ğŸ–¥ï¸ğŸ’¡

### 1. Clone the Repository


git clone https://github.com/abhirajadhikary06/EcoFix.git
cd EcoFix

### 2. Set Up the Virtual Environment

python -m venv env
source env/bin/activate  # For Linux/Mac
# OR
env\\Scripts\\activate  # For Windows

### 3. Install Dependencies

pip install -r requirements.txt

### 4. Run Migrations

python manage.py makemigrations
python manage.py migrate

### 5. Start the Server ğŸš€

python manage.py runserver

Now, open your browser and go to http://127.0.0.1:8000 to explore EcoFix! ğŸŒ¿
ğŸ–¼ï¸ Screenshots

ğŸŒ Home Page

ğŸ“¸ Submit Observation

ğŸ“Š Track Carbon Footprint

ğŸ¤ Contributing

We welcome contributions! ğŸ‘ Follow these simple steps: 1. Fork the repository ğŸ´ 2. Create a new branch for your feature (git checkout -b feature-name) ğŸŒ± 3. Commit your changes (git commit -m 'Add some feature') ğŸ’¾ 4. Push to the branch (git push origin feature-name) ğŸš€ 5. Open a Pull Request ğŸ“¬

ğŸ“œ License

This project is licensed under the MIT License.

Authors

Anik Chand, Abhiraj Adhikary, Anirban Chakraborty, Ayan Roy






### Global Disaster Network

Overview

The Global Disaster Network (GAN) is a comprehensive disaster management platform designed to empower communities, authorities, and individuals by providing real-time tools and resources to predict, monitor, and respond to natural disasters and calamities. Built with a focus on connectivity, accessibility, and transparency, GAN aims to reduce the impact of disasters through proactive measures, community engagement, and advanced technology.

This project leverages modern web technologies, AI-driven predictions, and real-time data to create a robust system for disaster preparedness and response. Below is a detailed breakdown of the features, setup instructions, and API documentation for developers.

Features

1. Prediction Map

The Prediction Map is a core feature of GAN, utilizing AI and machine learning to forecast potential natural disasters such as floods, wildfires, hurricanes, and earthquakes. Key aspects include:

Disaster Prediction: The map integrates historical data, weather patterns, and environmental factors to predict the likelihood of disasters in specific regions. For example, it can forecast flood risks based on rainfall data or wildfire risks based on temperature and humidity.
Nearest Hospital Locator: In the event of a predicted or ongoing disaster, the map highlights the nearest hospitals or shelters where users can seek refuge. It uses geolocation to provide real-time directions and estimated travel times.
Visual Representation: The map is interactive, displaying color-coded risk zones (e.g., red for high risk, yellow for moderate risk) and overlays for hospital locations.
2. Previous Disasters

This feature provides a historical database of past natural disasters, allowing users to learn from historical events and prepare for future ones.

Searchable Database: Users can search for disasters by location, date, or type (e.g., earthquake, tsunami).
Detailed Reports: Each entry includes details such as the disasterâ€™s impact (casualties, economic loss), response efforts, and lessons learned.
Educational Resource: Helps communities understand recurring disaster patterns in their area, fostering better preparedness.
3. Latest News Related to Disasters

Stay informed with real-time news updates on ongoing and recent disasters worldwide.

News Aggregation: GAN pulls in the latest disaster-related news from trusted sources, ensuring users have access to up-to-date information.
Localized News: Users can filter news by region to focus on disasters affecting their area.
Alerts: Push notifications for breaking news about disasters in the userâ€™s vicinity.
4. Community Connectivity

The Community Connectivity feature fosters collaboration among citizens during and after disasters, enabling them to support each other.

Disaster Reporting: Users can report disasters directly from their location, including details such as the type of disaster, severity, and current situation. Reports include geolocation data for precise mapping.
Communication Platform: Other users can view these reports, comment, and offer assistance or advice. For example, a user reporting a flood can receive messages from others offering shelter or supplies.
Community Forum: A dedicated space for users to discuss disaster preparedness, share experiences, and build local support networks.
5. Authority Login

A separate login portal for disaster management authorities provides a centralized dashboard to monitor and respond to disasters.

Disaster Monitoring: Authorities can view all reported disasters on a single map, with filters for type, severity, and location.
Real-Time Updates: Receive live updates from user reports and prediction models to prioritize response efforts.
Coordination Tools: Send alerts to citizens, coordinate with hospitals, and manage resources efficiently.
6. Chatbot for Natural Disasters and Calamities

An AI-powered chatbot provides instant support and information related to natural disasters.

Disaster Information: Users can ask questions like â€œWhat should I do during an earthquake?â€ or â€œHow do I prepare for a hurricane?â€ The chatbot provides actionable advice based on best practices.
Real-Time Assistance: During a disaster, the chatbot can guide users to the nearest shelter or hospital and provide safety tips.
Multilingual Support: Available in multiple languages to ensure accessibility for diverse communities.
7. API Documentation

GAN provides a public API for developers to access previous disaster data, enabling integration with other applications.

Endpoint: GET /disasters/
Description: Fetch a list of previous disasters.
Parameters:
location (optional): Filter by location (e.g., "California").
type (optional): Filter by disaster type (e.g., "earthquake").
date_from (optional): Filter by start date (e.g., "2023-01-01").
date_to (optional): Filter by end date (e.g., "2023-12-31").
Response:
[
      {
    "year": 2020,
    "disaster_type": "Flood",
    "country": "India",
    "region": "Kerala",
    "location": "Alappuzha",
},
  ...
]
Authentication: Requires an API key, which can be obtained by registering on the GAN developer portal.
Rate Limit: 1000 requests per hour per API key.
8. Disaster Management Educational Videos

This feature provides users with access to curated educational videos on disaster management, helping them prepare for various types of natural disasters.

Disaster Type Selection: Users can select a specific disaster type (e.g., earthquake, flood, wildfire) to view relevant educational content.
YouTube Integration: The platform integrates with YouTube to display disaster management videos from trusted sources.
Interactive Learning: Videos include actionable tips, safety measures, and preparation guidelines to help users effectively respond to disasters.
Localized Content: Where available, videos tailored to specific regions or languages are prioritized to ensure relevance and accessibility.
Continuous Updates: The video library is regularly updated to include the latest and most accurate information on disaster management.
Installation

Prerequisites

Python 13.1
Django
A modern web browser (Chrome, Firefox, Edge)
API keys for map services (e.g., Google Maps API) and news aggregation (e.g., NewsAPI)
Setup Instructions

Clone the Repository:

git clone https://github.com/global-alert-network/gan.git
cd floodless
Install Dependencies:

pip install django
Configure Environment Variables: Create a .env file in the root directory and add the following:

GOOGLE_MAPS_API_KEY=your_google_maps_api_key
NEWS_API_KEY=your_news_api_key
DATABASE_URL=your_database_url
API_KEY=your_gan_api_key
Run the Application:

python manage.py runserver
The app will be available at http://localhost:8000.

Usage

Access the Platform:

Open your browser and navigate to http://localhost:8000 (or the deployed URL if hosted).
Register as a user to access community features, or log in as an authority using the separate login portal.
Explore Features:

Use the Prediction Map to view disaster forecasts and locate nearby hospitals.
Check the Previous Disasters section to learn about historical events.
Stay updated with the Latest News section.
Engage with the Community Connectivity feature to report disasters or communicate with others.
Authorities can log in to monitor and manage disaster responses.
Interact with the Chatbot for disaster-related guidance.
Developers can use the API to fetch disaster data for their applications.
Technologies Used

Frontend: HTML, Bulma CSS
Backend: Django
Database: PostgreSQL (for storing disaster data, user reports, etc.)
APIs:
Google Maps API (for Prediction Map and hospital locator)
NewsAPI (for latest news)
OpenWeather (for weather updates)
AI/ML: TensorFlow.js (for disaster prediction models)
Chatbot: Dialogflow (for natural language processing)
Styling: Bulma CSS
Contributing

We welcome contributions to the Global Disaster Network! To contribute:

Fork the repository.
Create a new branch (git checkout -b feature/your-feature).
Make your changes and commit them (git commit -m "Add your feature").
Push to your branch (git push origin feature/your-feature).
Open a pull request with a detailed description of your changes.
Please ensure your code follows our coding standards and includes tests where applicable.

License

This project is licensed under the MIT License.

Acknowledgments

Inspired by global disaster management initiatives like the United Nations Office for Disaster Risk Reduction (UNDRR).
Thanks to the open-source community for providing tools and libraries that made this project possible.
Special thanks to contributors who helped shape the vision of GAN.
The Global Disaster Network is committed to making the world a safer place by empowering communities with the tools they need to face natural disasters. Join us in building a more resilient future! ğŸŒ


Authors

Anik Chand, Abhiraj Adhikary, Ayan Roy, Bholanath Dey








### Secure Line

Same as the project "Report Connect"








### EcoMate

same as project "EcoFix"









### 








